// SPDX-FileCopyrightText: 2020 SAP SE or an SAP affiliate company
// SPDX-License-Identifier: Apache-2.0

package apicmd

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/sapcc/go-bits/logg"
	"github.com/sapcc/go-bits/must"
	"github.com/sapcc/go-bits/osext"
	"github.com/sapcc/go-bits/sqlext"

	"github.com/sapcc/keppel/internal/keppel"
	"github.com/sapcc/keppel/internal/models"
	"github.com/sapcc/keppel/internal/tasks"
)

type peeringConfig []struct {
	Hostname             string `json:"hostname"`
	UseForPullDelegation *bool  `json:"use_for_pull_delegation"`
}

var createOrUpdatePeerQuery = sqlext.SimplifyWhitespace(`
	INSERT INTO peers (hostname, use_for_pull_delegation) VALUES ($1, $2)
		ON CONFLICT (hostname) DO UPDATE SET use_for_pull_delegation = EXCLUDED.use_for_pull_delegation
`)

func runPeering(ctx context.Context, cfg keppel.Configuration, db *keppel.DB) {
	isPeerHostName := make(map[string]bool)

	var peeringCfg peeringConfig
	decoder := json.NewDecoder(strings.NewReader(osext.GetenvOrDefault("KEPPEL_PEERS", "[]")))
	decoder.DisallowUnknownFields()
	must.Succeed(decoder.Decode(&peeringCfg))

	// add missing entries to `peers` table
	for _, peer := range peeringCfg {
		isPeerHostName[peer.Hostname] = true

		useForPullDelegation := true
		if peer.UseForPullDelegation != nil {
			useForPullDelegation = *peer.UseForPullDelegation
		}
		_ = must.Return(db.Exec(createOrUpdatePeerQuery, peer.Hostname, useForPullDelegation))
	}

	// remove old entries from `peers` table
	var allPeers []models.Peer
	_ = must.Return(db.Select(&allPeers, `SELECT * FROM peers`))
	for _, peer := range allPeers {
		if !isPeerHostName[peer.HostName] {
			_ = must.Return(db.Delete(&peer))
		}
	}

	go func() {
		ticker := time.NewTicker(10 * time.Second)
		defer ticker.Stop()

		for {
			select {
			case <-ctx.Done():
				return
			case <-ticker.C:
				err := tryIssueNewPasswordForPeer(ctx, cfg, db)
				if err != nil {
					logg.Error("cannot issue new peer password: " + err.Error())
				}
			}
		}
	}()
}

// WARNING: This must be run in a transaction, or else `FOR UPDATE SKIP LOCKED`
// will not work as expected.
var getNextPeerQuery = sqlext.SimplifyWhitespace(`
	SELECT * FROM peers
	 WHERE last_peered_at < $1 OR last_peered_at IS NULL
	 ORDER BY COALESCE(last_peered_at, TO_TIMESTAMP(-1)) ASC LIMIT 1
	   FOR UPDATE SKIP LOCKED
`)

func tryIssueNewPasswordForPeer(ctx context.Context, cfg keppel.Configuration, db *keppel.DB) error {
	tx, err := db.Begin()
	if err != nil {
		return err
	}
	defer sqlext.RollbackUnlessCommitted(tx)

	// select next peer that needs a new password, if any
	var peer models.Peer
	err = tx.SelectOne(&peer, getNextPeerQuery, time.Now().Add(-10*time.Minute))
	if errors.Is(err, sql.ErrNoRows) {
		// nothing to do
		//nolint:errcheck
		tx.Rollback() // avoid the log line generated by sqlext.RollbackUnlessCommitted()
		return nil
	}
	if err != nil {
		return err
	}

	// issue password (this will also commit the transaction)
	return tasks.IssueNewPasswordForPeer(ctx, cfg, db, tx, peer)
}
